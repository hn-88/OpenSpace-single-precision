*** Begin Patch
*** Update File: ghoul/src/opengl/programobject.cpp
@@
 #include <ghoul/filesystem/filesystem.h>
 #include <ghoul/logging/logmanager.h>
+#include <ghoul/opengl/uniform_conversion.h>
 #include <glm/gtc/type_ptr.hpp>
 #include <filesystem>
@@
 void ProgramObject::setAttribute(GLuint location, const glm::vec2& value) {
     ghoul_assert(location != GL_INVALID_INDEX, "Location must not be GL_INVALID_INDEX");
     glVertexAttrib2fv(location, value_ptr(value));
 }
 
 void ProgramObject::setAttribute(GLuint location, const glm::vec3& value) {
     ghoul_assert(location != GL_INVALID_INDEX, "Location must not be GL_INVALID_INDEX");
     glVertexAttrib3fv(location, value_ptr(value));
 }
 
 void ProgramObject::setAttribute(GLuint location, const glm::vec4& value) {
     ghoul_assert(location != GL_INVALID_INDEX, "Location must not be GL_INVALID_INDEX");
     glVertexAttrib4fv(location, value_ptr(value));
 }
 
 void ProgramObject::setAttribute(GLuint location, GLdouble value) {
     ghoul_assert(location != GL_INVALID_INDEX, "Location must not be GL_INVALID_INDEX");
-    glVertexAttribL1d(location, value);
+    // Convert double -> float at GL boundary
+    ghoul::opengl::util::VertexAttrib1d_as_f(location, value);
 }
 
 void ProgramObject::setAttribute(GLuint location, GLdouble v1, GLdouble v2) {
     ghoul_assert(location != GL_INVALID_INDEX, "Location must not be GL_INVALID_INDEX");
-    glVertexAttribL2d(location, v1, v2);
+    ghoul::opengl::util::VertexAttrib2d_as_f(location, v1, v2);
 }
 
 void ProgramObject::setAttribute(GLuint location, GLdouble v1, GLdouble v2, GLdouble v3) {
     ghoul_assert(location != GL_INVALID_INDEX, "Location must not be GL_INVALID_INDEX");
-    glVertexAttribL3d(location, v1, v2, v3);
+    ghoul::opengl::util::VertexAttrib3d_as_f(location, v1, v2, v3);
 }
 
 void ProgramObject::setAttribute(GLuint location,
                                  GLdouble v1, GLdouble v2, GLdouble v3, GLdouble v4)
 {
     ghoul_assert(location != GL_INVALID_INDEX, "Location must not be GL_INVALID_INDEX");
-    glVertexAttribL4d(location, v1, v2, v3, v4);
+    ghoul::opengl::util::VertexAttrib4d_as_f(location, v1, v2, v3, v4);
 }
 
 void ProgramObject::setAttribute(GLuint location, const glm::dvec2& value) {
     ghoul_assert(location != GL_INVALID_INDEX, "Location must not be GL_INVALID_INDEX");
-    glVertexAttribL2dv(location, value_ptr(value));
+    ghoul::opengl::util::VertexAttrib2dv_as_fv(location, value_ptr(value));
 }
 
 void ProgramObject::setAttribute(GLuint location, const glm::dvec3& value) {
     ghoul_assert(location != GL_INVALID_INDEX, "Location must not be GL_INVALID_INDEX");
-    glVertexAttribL3dv(location, value_ptr(value));
+    ghoul::opengl::util::VertexAttrib3dv_as_fv(location, value_ptr(value));
 }
 
 void ProgramObject::setAttribute(GLuint location, const glm::dvec4& value) {
     ghoul_assert(location != GL_INVALID_INDEX, "Location must not be GL_INVALID_INDEX");
-    glVertexAttribL4dv(location, value_ptr(value));
+    ghoul::opengl::util::VertexAttrib4dv_as_fv(location, value_ptr(value));
 }
@@
 void ProgramObject::setAttribute(GLuint location, const glm::mat2x2& value,
                                  Transpose transpose)
 {
     ghoul_assert(location != GL_INVALID_INDEX, "Location must not be GL_INVALID_INDEX");
     if (transpose) {
         setAttribute(location, glm::transpose(value));
     }
     else {
         glVertexAttrib2fv(location, value_ptr(value[0]));
         glVertexAttrib2fv(location + 1, value_ptr(value[1]));
     }
 }
@@
 void ProgramObject::setAttribute(GLuint location, const glm::mat2x3& value,
                                  Transpose transpose)
 {
     ghoul_assert(location != GL_INVALID_INDEX, "Location must not be GL_INVALID_INDEX");
     if (transpose) {
         setAttribute(location, glm::transpose(value));
     }
     else {
         glVertexAttrib3fv(location, value_ptr(value[0]));
         glVertexAttrib3fv(location + 1, value_ptr(value[1]));
     }
 }
@@
 void ProgramObject::setAttribute(GLuint location, const glm::mat2x4& value,
                                  Transpose transpose)
 {
     ghoul_assert(location != GL_INVALID_INDEX, "Location must not be GL_INVALID_INDEX");
     if (transpose) {
         setAttribute(location, glm::transpose(value));
     }
     else {
         glVertexAttrib4fv(location, value_ptr(value[0]));
         glVertexAttrib4fv(location + 1, value_ptr(value[1]));
     }
 }
@@
 void ProgramObject::setAttribute(GLuint location, const glm::mat3x2& value,
                                  Transpose transpose)
 {
     ghoul_assert(location != GL_INVALID_INDEX, "Location must not be GL_INVALID_INDEX");
     if (transpose) {
         setAttribute(location, glm::transpose(value));
     }
     else {
         glVertexAttrib2fv(location, value_ptr(value[0]));
         glVertexAttrib2fv(location + 1, value_ptr(value[1]));
         glVertexAttrib2fv(location + 2, value_ptr(value[2]));
     }
 }
@@
 void ProgramObject::setAttribute(GLuint location, const glm::mat3x3& value,
                                  Transpose transpose)
 {
     ghoul_assert(location != GL_INVALID_INDEX, "Location must not be GL_INVALID_INDEX");
     if (transpose) {
         setAttribute(location, glm::transpose(value));
     }
     else {
         glVertexAttrib3fv(location, value_ptr(value[0]));
         glVertexAttrib3fv(location + 1, value_ptr(value[1]));
         glVertexAttrib3fv(location + 2, value_ptr(value[2]));
     }
 }
@@
 void ProgramObject::setAttribute(GLuint location, const glm::mat3x4& value,
                                  Transpose transpose)
 {
     ghoul_assert(location != GL_INVALID_INDEX, "Location must not be GL_INVALID_INDEX");
     if (transpose) {
         setAttribute(location, glm::transpose(value));
     }
     else {
         glVertexAttrib4fv(location, value_ptr(value[0]));
         glVertexAttrib4fv(location + 1, value_ptr(value[1]));
         glVertexAttrib4fv(location + 2, value_ptr(value[2]));
     }
 }
@@
 void ProgramObject::setAttribute(GLuint location, const glm::mat4x2& value,
                                  Transpose transpose)
 {
     ghoul_assert(location != GL_INVALID_INDEX, "Location must not be GL_INVALID_INDEX");
     if (transpose) {
         setAttribute(location, glm::transpose(value));
     }
     else {
         glVertexAttrib2fv(location, value_ptr(value[0]));
         glVertexAttrib2fv(location + 1, value_ptr(value[1]));
         glVertexAttrib2fv(location + 2, value_ptr(value[2]));
         glVertexAttrib2fv(location + 3, value_ptr(value[3]));
     }
 }
@@
 void ProgramObject::setAttribute(GLuint location, const glm::mat4x3& value,
                                  Transpose transpose)
 {
     ghoul_assert(location != GL_INVALID_INDEX, "Location must not be GL_INVALID_INDEX");
     if (transpose) {
         setAttribute(location, glm::transpose(value));
     }
     else {
         glVertexAttrib3fv(location, value_ptr(value[0]));
         glVertexAttrib3fv(location + 1, value_ptr(value[1]));
         glVertexAttrib3fv(location + 2, value_ptr(value[2]));
         glVertexAttrib3fv(location + 3, value_ptr(value[3]));
     }
 }
@@
 void ProgramObject::setAttribute(GLuint location, const glm::mat4x4& value,
                                  Transpose transpose)
 {
     ghoul_assert(location != GL_INVALID_INDEX, "Location must not be GL_INVALID_INDEX");
     if (transpose) {
         setAttribute(location, glm::transpose(value));
     }
     else {
         glVertexAttrib4fv(location, value_ptr(value[0]));
         glVertexAttrib4fv(location + 1, value_ptr(value[1]));
         glVertexAttrib4fv(location + 2, value_ptr(value[2]));
         glVertexAttrib4fv(location + 3, value_ptr(value[3]));
     }
 }
@@
 void ProgramObject::setAttribute(GLuint location, const glm::dmat2x2& value,
                                  Transpose transpose)
 {
     ghoul_assert(location != GL_INVALID_INDEX, "Location must not be GL_INVALID_INDEX");
     if (transpose) {
         setAttribute(location, glm::transpose(value));
     }
     else {
-        glVertexAttribL2dv(location, value_ptr(value[0]));
-        glVertexAttribL2dv(location + 1, value_ptr(value[1]));
+        ghoul::opengl::util::VertexAttribMatrix2_as_fv(location,
+            value_ptr(value[0]), value_ptr(value[1]));
     }
 }
@@
 void ProgramObject::setAttribute(GLuint location, const glm::dmat2x3& value,
                                  Transpose transpose)
 {
     ghoul_assert(location != GL_INVALID_INDEX, "Location must not be GL_INVALID_INDEX");
     if (transpose) {
         setAttribute(location, glm::transpose(value));
     }
     else {
-        glVertexAttribL3dv(location, value_ptr(value[0]));
-        glVertexAttribL3dv(location + 1, value_ptr(value[1]));
+        ghoul::opengl::util::VertexAttribMatrix3_as_fv(location,
+            value_ptr(value[0]), value_ptr(value[1]), value_ptr(value[2]));
     }
 }
@@
 void ProgramObject::setAttribute(GLuint location, const glm::dmat2x4& value,
                                  Transpose transpose)
 {
     ghoul_assert(location != GL_INVALID_INDEX, "Location must not be GL_INVALID_INDEX");
     if (transpose) {
         setAttribute(location, glm::transpose(value));
     }
     else {
-        glVertexAttribL4dv(location, value_ptr(value[0]));
-        glVertexAttribL4dv(location + 1, value_ptr(value[1]));
+        ghoul::opengl::util::VertexAttribMatrix4_as_fv(location,
+            value_ptr(value[0]), value_ptr(value[1]), value_ptr(value[2]), value_ptr(value[3]));
     }
 }
@@
 void ProgramObject::setAttribute(GLuint location, const glm::dmat3x2& value,
                                  Transpose transpose)
 {
     ghoul_assert(location != GL_INVALID_INDEX, "Location must not be GL_INVALID_INDEX");
     if (transpose) {
         setAttribute(location, glm::transpose(value));
     }
     else {
-        glVertexAttribL2dv(location, value_ptr(value[0]));
-        glVertexAttribL2dv(location + 1, value_ptr(value[1]));
-        glVertexAttribL2dv(location + 2, value_ptr(value[2]));
+        ghoul::opengl::util::VertexAttribMatrix2_as_fv(location,
+            value_ptr(value[0]), value_ptr(value[1]));
+        // third column (2x) -> also columns processed with 2 components each
+        ghoul::opengl::util::VertexAttrib2dv_as_fv(location + 2, value_ptr(value[2]));
     }
 }
@@
 void ProgramObject::setAttribute(GLuint location, const glm::dmat3x3& value,
                                  Transpose transpose)
 {
     ghoul_assert(location != GL_INVALID_INDEX, "Location must not be GL_INVALID_INDEX");
     if (transpose) {
         setAttribute(location, glm::transpose(value));
     }
     else {
-        glVertexAttribL3dv(location, value_ptr(value[0]));
-        glVertexAttribL3dv(location + 1, value_ptr(value[1]));
-        glVertexAttribL3dv(location + 2, value_ptr(value[2]));
+        ghoul::opengl::util::VertexAttribMatrix3_as_fv(location,
+            value_ptr(value[0]), value_ptr(value[1]), value_ptr(value[2]));
     }
 }
@@
 void ProgramObject::setAttribute(GLuint location, const glm::dmat3x4& value,
                                  Transpose transpose)
 {
     ghoul_assert(location != GL_INVALID_INDEX, "Location must not be GL_INVALID_INDEX");
     if (transpose) {
         setAttribute(location, glm::transpose(value));
     }
     else {
-        glVertexAttribL4dv(location, value_ptr(value[0]));
-        glVertexAttribL4dv(location + 1, value_ptr(value[1]));
-        glVertexAttribL4dv(location + 2, value_ptr(value[2]));
+        ghoul::opengl::util::VertexAttribMatrix4_as_fv(location,
+            value_ptr(value[0]), value_ptr(value[1]), value_ptr(value[2]), value_ptr(value[3]));
     }
 }
@@
 void ProgramObject::setAttribute(GLuint location, const glm::dmat4x2& value,
                                  Transpose transpose)
 {
     ghoul_assert(location != GL_INVALID_INDEX, "Location must not be GL_INVALID_INDEX");
     if (transpose) {
         setAttribute(location, glm::transpose(value));
     }
     else {
-        glVertexAttribL2dv(location, value_ptr(value[0]));
-        glVertexAttribL2dv(location + 1, value_ptr(value[1]));
-        glVertexAttribL2dv(location + 2, value_ptr(value[2]));
-        glVertexAttribL2dv(location + 3, value_ptr(value[3]));
+        ghoul::opengl::util::VertexAttribMatrix2_as_fv(location,
+            value_ptr(value[0]), value_ptr(value[1]));
+        ghoul::opengl::util::VertexAttrib2dv_as_fv(location + 2, value_ptr(value[2]));
+        ghoul::opengl::util::VertexAttrib2dv_as_fv(location + 3, value_ptr(value[3]));
     }
 }
@@
 void ProgramObject::setAttribute(GLuint location, const glm::dmat4x3& value,
                                  Transpose transpose)
 {
     ghoul_assert(location != GL_INVALID_INDEX, "Location must not be GL_INVALID_INDEX");
     if (transpose) {
         setAttribute(location, glm::transpose(value));
     }
     else {
-        glVertexAttribL3dv(location, value_ptr(value[0]));
-        glVertexAttribL3dv(location + 1, value_ptr(value[1]));
-        glVertexAttribL3dv(location + 2, value_ptr(value[2]));
-        glVertexAttribL3dv(location + 3, value_ptr(value[3]));
+        ghoul::opengl::util::VertexAttribMatrix3_as_fv(location,
+            value_ptr(value[0]), value_ptr(value[1]), value_ptr(value[2]));
+        ghoul::opengl::util::VertexAttrib3dv_as_fv(location + 3, value_ptr(value[3]));
     }
 }
@@
 void ProgramObject::setAttribute(GLuint location, const glm::dmat4x4& value,
                                  Transpose transpose)
 {
     ghoul_assert(location != GL_INVALID_INDEX, "Location must not be GL_INVALID_INDEX");
     if (transpose) {
         setAttribute(location, glm::transpose(value));
     }
     else {
-        glVertexAttribL4dv(location, value_ptr(value[0]));
-        glVertexAttribL4dv(location + 1, value_ptr(value[1]));
-        glVertexAttribL4dv(location + 2, value_ptr(value[2]));
-        glVertexAttribL4dv(location + 3, value_ptr(value[3]));
+        ghoul::opengl::util::VertexAttribMatrix4_as_fv(location,
+            value_ptr(value[0]), value_ptr(value[1]), value_ptr(value[2]), value_ptr(value[3]));
     }
 }
*** End Patch

